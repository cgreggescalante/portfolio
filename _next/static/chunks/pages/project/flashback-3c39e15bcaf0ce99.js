(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[723],{3695:function(e,t,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/project/flashback",function(){return a(2223)}])},2223:function(e,t,a){"use strict";a.r(t);var o=a(5893),r=a(8182);let i=()=>(0,o.jsxs)(r.Z,{children:[(0,o.jsx)(r.Z.Header,{as:"h1",children:"Flashback"}),(0,o.jsxs)(r.Z.Body,{children:[(0,o.jsx)(r.Z.Text,{children:'This project is an ongoing effort to analyze and visualize my lifetime Spotify listening history. The data used for this project was obtained through Spotify\'s "Download your data" feature, specifically the Extended Streaming History download. You can request a copy of your own data by navigating to the Spotify website, opening the Account Overview, and going to Privacy Settings.'}),(0,o.jsx)(r.Z.Text,{children:"After requesting my data, it took nearly a month for it to become available for download. I suppose this wait is quite reasonable, considering some of the data was nealy 4 years old, and likely no longer used by their recommendation engine. Spotify provides the data in JSON form, split so that each file contains about 15 to 16 thousand plays. A single play being a record of the user starting a track, listening for any amount of time, then ending it. My data was nearly 128 thousand plays over the last 4 years."}),(0,o.jsx)(r.Z.Text,{children:"My next step was to organize this data into a more usable form. I briefly considered only storing the data in a local SQLite database, and just serving static charts and tables through GitHub. This would have quickly become bloated if I wanted to view history for individual tracks or artists. My next option was MongoDB, which I had some experience using in a certification course. I pushed ahead with that option, until I found that the drivers for MongoDB don't allow access from the client. Rats. After some research, I settled on Oracle Cloud Infrastructure, which ended up being a great option."}),(0,o.jsx)(r.Z.Text,{children:"Oracle offers a large amount of free hosting resources, including a variety of database options. I chose to use their Autonomous Database solution, which makes it very easy to create and manage a database. It even includes a simple interface for creating a REST API that translates http calls directly into SQL queries."})]})]});t.default=i},8182:function(e,t,a){"use strict";a.d(t,{Z:function(){return j}});var o=a(4184),r=a.n(o),i=a(7294),n=a(6792),s=a(6611),d=a(9602),l=a(5893);let c=i.forwardRef(({bsPrefix:e,className:t,variant:a,as:o="img",...i},s)=>{let d=(0,n.vE)(e,"card-img");return(0,l.jsx)(o,{ref:s,className:r()(a?`${d}-${a}`:d,t),...i})});c.displayName="CardImg";var h=a(9059);let u=i.forwardRef(({bsPrefix:e,className:t,as:a="div",...o},s)=>{let d=(0,n.vE)(e,"card-header"),c=(0,i.useMemo)(()=>({cardHeaderBsPrefix:d}),[d]);return(0,l.jsx)(h.Z.Provider,{value:c,children:(0,l.jsx)(a,{ref:s,...o,className:r()(t,d)})})});u.displayName="CardHeader";let f=(0,d.Z)("h5"),y=(0,d.Z)("h6"),g=(0,s.Z)("card-body"),m=(0,s.Z)("card-title",{Component:f}),p=(0,s.Z)("card-subtitle",{Component:y}),b=(0,s.Z)("card-link",{Component:"a"}),v=(0,s.Z)("card-text",{Component:"p"}),w=(0,s.Z)("card-footer"),x=(0,s.Z)("card-img-overlay"),Z=i.forwardRef(({bsPrefix:e,className:t,bg:a,text:o,border:i,body:s,children:d,as:c="div",...h},u)=>{let f=(0,n.vE)(e,"card");return(0,l.jsx)(c,{ref:u,...h,className:r()(t,f,a&&`bg-${a}`,o&&`text-${o}`,i&&`border-${i}`),children:s?(0,l.jsx)(g,{children:d}):d})});Z.displayName="Card",Z.defaultProps={body:!1};var j=Object.assign(Z,{Img:c,Title:m,Subtitle:p,Body:g,Link:b,Text:v,Header:u,Footer:w,ImgOverlay:x})}},function(e){e.O(0,[774,888,179],function(){return e(e.s=3695)}),_N_E=e.O()}]);